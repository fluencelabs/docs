# Register Aqua services (as plugins?)

# TODO: adapt to JS Client

# TODO: mention aqua arrays and their types convertion

## Bullets

- write aqua
- export service
- compile
- register service

## Understanding the compiler output

```aqua
service ServiceName:
    -- service interface
```

For every exported `service` declaration, the compiler will generate two entities: a service interface under the name `{serviceName}Def` and a function named `register{serviceName}` with several overloads. First, let's describe the most complete one using the following example:

```typescript
export interface ServiceNameDef {
  //... service function definitions
}

export function registerServiceName(
  peer: FluencePeer,
  serviceId: string,
  service: ServiceNameDef
): void;
```

Here,

- `peer` is the Fluence Peer instance where the handler should be registered. The peer can be omitted. In that case the default Fluence Peer will be used instead.
- `serviceId` is the name of the service id. If the service was defined with the default service id in Aqua code, this argument can be omitted.
- `service` is the handler for the service.

Depending on whether or not the services was defined with the default id the number of overloads will be different. In the case it **is defined**, there would be four overloads:

```typescript
// (1)
export function registerServiceName(
  //
  service: ServiceNameDef
): void;

// (2)
export function registerServiceName(
  serviceId: string,
  service: ServiceNameDef
): void;

// (3)
export function registerServiceName(
  peer: FluencePeer,
  service: ServiceNameDef
): void;

// (4)
export function registerServiceName(
  peer: FluencePeer,
  serviceId: string,
  service: ServiceNameDef
): void;
```

1. Uses the default Fluence Peer and the default id taken from Aqua definition.
2. Uses the default Fluence Peer and specifies the service id explicitly.
3. The default id is taken from Aqua definition. The peer is specified explicitly.
4. Both the peer and the service id are specified.

If the default id **is not defined** in Aqua code, the overloads will exclude those without service id:

```typescript
// (1)
export function registerServiceName(
  serviceId: string,
  service: ServiceNameDef
): void;

// (2)
export function registerServiceName(
  peer: FluencePeer,
  serviceId: string,
  service: ServiceNameDef
): void;
```

1. Uses the default Fluence Peer and specifies the service id
   explicitly.
2. Both the peer and the service id are specified.

### Type conversion

Same as in call function. But no arrow types

### Service interface

The service interface type follows closely the definition in Aqua code. It has the form of an object which keys correspond to the names of service members and the values are functions of the type translated from Aqua definition (see [Type conversion](#type-conversion)). For example, for the following Aqua definition:

```aqua
service Calc("calc"):
    add(n: f32)
    subtract(n: f32)
    multiply(n: f32)
    divide(n: f32)
    reset()
    getResult() -> f32
```

The typescript interface will be:

```typescript
export interface CalcDef {
  add: (n: number, callParams: CallParams<"n">) => void | Promise<void>;
  subtract: (n: number, callParams: CallParams<"n">) => void | Promise<void>;
  multiply: (n: number, callParams: CallParams<"n">) => void | Promise<void>;
  divide: (n: number, callParams: CallParams<"n">) => void | Promise<void>;
  reset: (callParams: CallParams<null>) => void | Promise<void>;
  getResult: (callParams: CallParams<null>) => number | Promise<number>;
}
```

`CallParams` will be described later in the section.

For the service definitions, arguments are named (see calc example above).

### Using asynchronous code in callbacks

Typescript code generated by Aqua compiler has two scenarios where a user should specify a callback function. These are services and callback arguments of a function in Aqua. If you look at the return type of the generated function, you will see a union of callback return type and the promise with this type, e.g., `string | Promise<string>`. Fluence-js supports both sync and async versions of callbacks and figures out which one is used under the hood. The callback can be made asynchronous like any other function in javascript: either return a Promise or mark it with the `async` keyword to take advantage of async-await pattern.

For example:

```aqua
func withCallback(callback: string -> ()):
  callback()

service MyService:
  callMe(string)
````

Here we are returning a promise:

```typescript
registerMyService({
  callMe: (arg): Promise<void> => {
    return new Promise((resolve) => {
      setTimeout(() => {
        console.log("I'm running 3 seconds after call");
        resolve();
      }, 3000);
    });
  },
});
```

And here we are using async-await pattern:

```typescript
await withCallback(async (arg) => {
  const data = await getStuffFromDatabase(arg);
  console.log("");
});
```
