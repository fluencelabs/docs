# Hello world example

## Intro

In this section we will show you how Fluence JS Client can be used to create a hello world application with Fluence stack.

## Aqua code

Let's start with the aqua code first:

```aqua
import Peer from "@fluencelabs/aqua-lib/builtin.aqua" -- (1)

service HelloWorld("hello-world"):                    -- (2)
    hello(str: string)
    getFortune() -> string

func sayHello():                                      -- (3)
    HelloWorld.hello("Hello, world!")

func tellFortune() -> string:                         -- (4)
    res <- HelloWorld.getFortune()
    <- res

func getRelayTime() -> u64:                           -- (5)
    on HOST_PEER_ID:
        ts <- Peer.timestamp_ms()
    <- ts
```

We need to import definitions to call standard Peer operations (1)

This file has three definitions.

(2) is a service named `HelloWorld`. A Service interfaces functions executable on a peer. We will register a handler for this interface in our TypeScript application.

(3) and (4) are functions `sayHello` and `tellFortune` correspondingly. These functions very simple. The only thing the first one does is calling the `hello` method of `HelloWorld` service located on the current peer. Similarly `tellFortune` calls the `getFortune` method from the same service and returns the value to the caller. We will show you how to call these function from the TypeScript application.

Finally we have a function (5) which demonstrate how to work with the network. It asks the current time from the relay peer and return back the our peer.

## Installing dependencies

Initialize an empty npm package:

```sh
npm init
```

We will need these three packages for the application runtime: JS Client API, JS Client implementation for Node.js and the package containing a well-maintained list of relay nodes.

```sh
npm install @fluencelabs/js-client.api @fluencelabs/js-client.node @fluencelabs/fluence-network-environment
```

To use Aqua compiler we will need Fluence CLI, but only as a development dependency

```sh
npm install --save-dev @fluencelabs/cli
```

Aqua comes with the standard library which can accessed from "@fluencelabs/aqua-lib" package. All the aqua packages are only needed at compiler time, so we install it as a development dependency

```sh
npm install --save-dev @fluencelabs/aqua-lib
```

And last, but no least we will need TypeScript

```
npm install --save-dev typescript
npx tsc --init
```

## Setting up aqua compiler

Let's put aqua described earlier into `aqua/hello-world.aqua` file. You probably want to keep the generated TypeScript in the same directory with other typescript files, usually `src`. Let's create the `src/_aqua` directory for that.

The overall project structure looks like this:

```
 ┣ aqua
 ┃ ┗ hello-world.aqua
 ┣ src
 ┃ ┣ _aqua
 ┃ ┃ ┗ hello-world.ts
 ┃ ┗ index.ts
 ┣ package-lock.json
 ┣ package.json
 ┗ tsconfig.json
```

To compile aqua we can use Fluence CLI with `npm`:

```sh
npx fluence aqua -i ./aqua/ -o ./src/_aqua
```

To watch for aqua file changes add `-w` flag:

```sh
npx fluence aqua -w -i ./aqua/ -o ./src/_aqua
```

We recommend to store this logic inside a script in `packages.json` file:

```javascript
{
  ...
  "scripts": {
    ...
    "compile-aqua": "fluence aqua -i ./aqua/ -o ./src/_aqua",
    "watch-aqua": "fluence aqua -w -i ./aqua/ -o ./src/_aqua"
  },
  ...
}
```

## Using the compiled code in TypeScript application

Using the code generated by the compiler is as easy as calling a function. The compiler generates all the boilerplate needed to send a particle into the network and wraps it into a single call. It also generate a function for service callback registration. Note that all the type information and therefore type checking and code completion facilities are there!

Let's see how use generated code in our application. `index.ts`:

```typescript
import "@fluencelabs/js-client.node"; // Import the JS Client implementation. Don't forget to add this import!
import { Fluence } from "@fluencelabs/js-client.api"; // Import the API for JS Client
import { kras } from "@fluencelabs/fluence-network-environment"; // Import list of possible relay nodes (network environment)
import {
  registerHelloWorld,
  sayHello,
  getRelayTime,
  tellFortune,
} from "./_aqua/hello-world"; // Aqua compiler provides functions which can be directly imported like any normal TypeScript function.

async function main() {
  await Fluence.connect(kras[3]); // Connecting to the fourth kras node.

  /*
  For every exported `service XXX` definition in aqua code, the compiler provides a `registerXXX` counterpart. These functions provide a type-safe way of registering callback handlers for the services. The callbacks are executed when the appropriate service is called in Aqua on the current peer. The handlers take form of the object where keys are the name of functions and the values are async functions used as the corresponding callbacks. For example in (4) we are registering handlers for `HelloWorld` service functions which outputs it's parameter to the console. Please note that the handlers can be implemented in both: synchronous and asynchronous way. The handler can be made asynchronous like any other function in javascript: either return a Promise or mark it with async keyword to take advantage of async-await pattern.
  */
  registerHelloWorld({
    hello: (str) => {
      console.log(str);
    },
    getFortune: async () => {
      await new Promise((resolve) => {
        setTimeout(resolve, 1000);
      });
      return "Wealth awaits you very soon.";
    },
  });

  /*
  For every exported `func XXX` definition in aqua code, the compiler provides an async function which can be directly called from typescript.
  For example we are calling aqua function called `sayHello`
  */
  await sayHello();

  /*
  And here we are call the function called `tellFortune`.
  Please keep in mind that all of the functions are asynchronous
  */
  console.log(await tellFortune());

  const relayTime = await getRelayTime();

  console.log("The relay time is: ", new Date(relayTime).toLocaleString());

  // You should call `disconnect` to prevent your application from hanging.
  await Fluence.disconnect();
}

main();
```

Let's try running the example:

```sh
node -r ts-node/register src/index.ts
```

If everything has been done correctly yuo should see `Hello, world!` in the console.
